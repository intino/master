def type(validator & class)
	package $package;

	import io.intino.master.data.validation.Issue;
	import io.intino.master.data.validation.RecordValidator;
	import io.intino.master.data.validation.TripleRecordStore;

	import java.util.List;
	import java.util.Map;
	import java.util.Objects;
	import java.util.stream.Stream;

	public class $name+FirstUpperCase~Validator implements RecordValidator {

		@Override
		public Stream<Issue> validate(TripleRecord record, TripleRecordStore store) {
			return record.attributes().entrySet().stream()
				.map(e -> validate(e, record, store))
				.filter(Objects::nonNull)
				.reduce(Stream::concat).orElse(Stream.empty());
		}

		protected Stream<Issue> validate(Map.Entry<String, List<TripleRecord.Value>> attrib, TripleRecord record, TripleRecordStore store) {
			switch(attrib.getKey()) {
				[$attribute+attribSwitchCase...[$NL]]
				default: return Stream.empty();
			}
		}

		[$attribute+validationMethod...[$NL$NL]]

		[$type+checkType...[$NL$NL]]
	}
end

def type(attribute) trigger(attribSwitchCase)
	case "$name": return validate$name+FirstUpperCase~(attrib.getValue(), record, store);
end

def type(attribute & entity) trigger(validationMethod)
	protected Stream<Issue> validate$name+FirstUpperCase~(List<TripleRecord.Value> values, TripleRecord record, TripleRecordStore store) {
		[$required+attributeNotDefined]
		[$optional+attributeNotDefined]
		if(values.size() > 1) return Stream.of(Issue.error("$name is defined " + values.size() + "times.").source(values.get(0).source()));
        return store.get(values.get(0).get()) != null
        	? Stream.empty()
        	: Stream.of(Issue.error("$name+FirstUpperCase " + values.get(0).get() + " does not exist.").source(values.get(0).source()));
	}
end

def type(attribute) !type(string) trigger(validationMethod)
	protected Stream<Issue> validate$name+FirstUpperCase~(List<TripleRecord.Value> values, TripleRecord record, TripleRecordStore store) {
		[$required+attributeNotDefined]
		[$optional+attributeNotDefined]
		if(values.size() > 1) return Stream.of(Issue.error("$name is defined " + values.size() + "times.").source(values.get(0).source()));
		return is$type+FirstUpperCase~(values.get(0).get())
			? Stream.empty()
			: Stream.of(Issue.error("$name is an invalid $type: " + values.get(0).get()).source(values.get(0).source()));
	}
end

def type(attribute) type(string) trigger(validationMethod)
	protected Stream<Issue> validate$name+FirstUpperCase~(List<TripleRecord.Value> values, TripleRecord record, TripleRecordStore store) {
		[$required+attributeNotDefined]
		[$optional+attributeNotDefined]
		if(values.size() > 1) return Stream.of(Issue.error("$name is defined " + values.size() + "times.").source(values.get(0).source()));
		return Stream.empty();
	}
end

def type(required) trigger(attributeNotDefined)
	if(values.isEmpty() || values.get(0).isEmpty()) return Stream.of(Issue.error("$name is not defined.").source(record.source()));
end

def type(optional & warning) trigger(attributeNotDefined)
	if(values.isEmpty() || values.get(0).isEmpty()) return Stream.of(Issue.warning("$name is not defined.").source(record.source()));
end

def type(optional) trigger(attributeNotDefined)
	if(values.isEmpty() || values.get(0).isEmpty()) return Stream.empty();
end

def type(type) type(double | integer | long | boolean) trigger(checkType)
	protected boolean is$name+FirstUpperCase~(String value) {
		try {
			$name+FirstUpperCase~.parse$name+FirstUpperCase~(value);
			return true;
		} catch(Exception e) {
		 	return false;
		}
	}
end

def type(type) type(localdate) trigger(checkType)
	protected boolean is$name+FirstUpperCase~(String value) {
		try {
			java.time.LocalDate.parse(value, java.time.format.DateTimeFormatter.ofPattern("$format"));
			return true;
		} catch(Exception e) {
		 	return false;
		}
	}
end

def type(type) type(localdatetime) trigger(checkType)
	protected boolean is$name+FirstUpperCase~(String value) {
		try {
			java.time.LocalDateTime.parse(value, java.time.format.DateTimeFormatter.ofPattern("$format"));
			return true;
		} catch(Exception e) {
		 	return false;
		}
	}
end

def type(type) type(instant) trigger(checkType)
	protected boolean is$name+FirstUpperCase~(String value) {
		try {
			java.time.Instant.ofEpochMilli(Long.parseLong(value));
			return true;
		} catch(Exception e) {
		 	return false;
		}
	}
end

def type(type) type(map) trigger(checkType)
	protected boolean is$name+FirstUpperCase~(String value) {
		try {
			java.util.Arrays.stream(value.split(";"))
				.map(e -> e.split("="))
				.collect(java.util.stream.Collectors.toMap(e -> e$[0$].trim(), e -> e$[1$].trim()));
			return true;
		} catch(Exception e) {
		 	return false;
		}
	}
end

def type(struct) trigger(checkType)
	protected boolean is$name+FirstUpperCase~(String value) {
		try {
        	List<String> values = java.util.Arrays.stream(value.split(",", -1)).map(v -> v.trim()).collect(java.util.stream.Collectors.toList());
            $struct+call;
            return true;
        } catch(Exception e) {
        	return false;
        }
	}
end

def trigger(call)
	new $package.structs.$name+firstUpperCase($attribute+parse...[, ])
end

def type(boolean) trigger(parse)
	Boolean.parseBoolean(values.get($index))
end

def type(int) trigger(parse)
	Integer.parseInt(values.get($index))
end

def type(double) trigger(parse)
	Double.parseDouble(values.get($index))
end

def type(localdate) trigger(parse)
	java.time.LocalDate.parse(values.get($index));
end

def type(localdatetime) trigger(parse)
	java.time.LocalDateTime.parse(values.get($index));
end

def type(instant) trigger(parse)
	java.time.Instant.parse(values.get($index));
end

def trigger(parse)
	values.get($index)
end