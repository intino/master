def type(master & interface)
	package $package;

	import java.util.List;
	import $package.entities.*;

	public interface Master {
		$entity+getterSignature...[$NL$NL]
	}
end

def type(master)
	package $package;

	import com.hazelcast.client.HazelcastClient;
    import com.hazelcast.client.config.ClientConfig;
    import com.hazelcast.core.EntryEvent;
    import com.hazelcast.core.HazelcastInstance;
    import com.hazelcast.map.IMap;
    import com.hazelcast.map.listener.EntryAddedListener;
    import com.hazelcast.map.listener.EntryEvictedListener;
    import com.hazelcast.map.listener.EntryRemovedListener;
    import com.hazelcast.map.listener.EntryUpdatedListener;
    import io.intino.master.model.Triple;

	import $package.entities.*;

	import java.util.ArrayList;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;
	import java.util.function.BiConsumer;
	import java.util.function.Consumer;

	import java.util.logging.ConsoleHandler;
    import java.util.logging.Handler;
    import java.util.logging.Level;
    import java.util.logging.LogManager;

	import static io.intino.master.model.Triple.SEPARATOR;

	public class MasterClient implements Master {
    	private static BiConsumer<String, Triple> publisher;
    	private final Map<String, Consumer<Triple>> removers = new HashMap<>() {{
    		$entity+remover...[$NL]
    	}};
    	private final Map<String, Consumer<Triple>> adders = new HashMap<>() {{
    		$entity+adder...[$NL]
    	}};
    	$entity+map...[$NL]
    	private final IMap<String, String> reverseSubjectFactors;
    	private final IMap<String, String> reversePredicateFactors;
		private HazelcastInstance hz;

    	public static MasterClient connect(String url) {
    		ClientConfig cfg = new ClientConfig();
    		cfg.getNetworkConfig().addAddress(url);
    		return new MasterClient(cfg);
    	}

    	public MasterClient() {
    		this(new ClientConfig());
    	}

    	public MasterClient(ClientConfig config) {
    		configureLogger();
    		this.hz = HazelcastClient.newHazelcastClient(config);
    		reverseSubjectFactors = hz.getMap("reverseSubjectFactors");
    		reversePredicateFactors = hz.getMap("reversePredicateFactors");
    		IMap<String, String> master = hz.getMap("master");
    		master.forEach((key, value) -> {
    			final String$[] subjectVerb = key.split(SEPARATOR);
    			add(new Triple(reverseSubjectFactors.get(subjectVerb$[0]).toString(), reversePredicateFactors.get(subjectVerb$[1]), value));
    		});
    		master.addEntryListener(new TripleEntryDispatcher(), true);
    		publisher = (publisher, triple) -> hz.getTopic("requests").publish(publisher + "##" + triple.toString());
    	}

    	$entity+getter...[$NL$NL]

    	public void stop() {
    		hz.shutdown();
    	}

    	public void publish(String publisher, Triple triple) {
    		if (this.publisher != null) this.publisher.accept(publisher, triple);
    	}

    	private void add(Triple triple) {
    		adders.getOrDefault(typeOf(triple), t -> {}).accept(triple);
    	}

    	private void remove(Triple triple) {
    		removers.getOrDefault(typeOf(triple), t -> {}).accept(triple);
    	}

    	$entity+add...[$NL$NL]

    	$entity+remove...[$NL$NL]

    	private String typeOf(Triple triple) {
    		return triple.subject().split(":")$[1].toLowerCase();
    	}

    	private static void configureLogger() {
			java.util.logging.Logger rootLogger = LogManager.getLogManager().getLogger("");
			rootLogger.setLevel(Level.WARNING);
			for (Handler h : rootLogger.getHandlers()) rootLogger.removeHandler(h);
			final ConsoleHandler handler = new ConsoleHandler();
			handler.setLevel(Level.WARNING);
			handler.setFormatter(new io.intino.alexandria.logger.Formatter());
			rootLogger.setUseParentHandlers(false);
			rootLogger.addHandler(handler);
		}

    	public class TripleEntryDispatcher implements EntryAddedListener<String, String>, EntryUpdatedListener<String, String>, EntryRemovedListener<String, String>, EntryEvictedListener<String, String> {

    		@Override
    		public void entryAdded(EntryEvent<String, String> event) {
    			add(triple(event));
    		}

    		@Override
    		public void entryUpdated(EntryEvent<String, String> event) {
    			add(triple(event));
    		}

    		@Override
    		public void entryRemoved(EntryEvent<String, String> event) {
    			remove(triple(event));
    		}

    		@Override
    		public void entryEvicted(EntryEvent<String, String> event) {
    			remove(triple(event));
    		}

    		private Triple triple(EntryEvent<String, String> event) {
    			final String$[] subjectVerb = event.getKey().split(SEPARATOR);
    			return new Triple(reverseSubjectFactors.get(subjectVerb$[0]).toString(), reversePredicateFactors.get(subjectVerb$[1]), event.getValue());
    		}
    	}
    }
end

def !type(abstract) trigger(remover)
	put("$name+lowerCase", MasterClient.this::removeFrom$name+FirstUpperCase);
end


def !type(abstract) trigger(adder)
	put("$name+lowerCase", MasterClient.this::addTo$name+FirstUpperCase);
end

def trigger(map)
	private final Map<String, $name+FirstUpperCase> $name+FirstLowerCase~Map = new HashMap<>();
end

def !type(abstract) trigger(add)
	private void addTo$name+FirstUpperCase(Triple triple) {
    	if (!$name+firstLowerCase~Map.containsKey(triple.subject())) $name+firstLowerCase~Map.put(triple.subject(), new $name+FirstUpperCase(triple.subject(), this));
    	$name+firstLowerCase~Map.get(triple.subject()).add(triple);
    }
end

def !type(abstract) trigger(remove)
	private void removeFrom$name+FirstUpperCase(Triple triple) {
		$name+firstLowerCase~Map.computeIfPresent(triple.subject(), (k, v) -> v.remove(triple));
	}
end

def trigger(getter)
	public $name+FirstUpperCase $name+firstLowerCase(String id) {
		return $name+firstLowerCase~Map.get(id);
	}

	public List<$name+FirstUpperCase> $name+Plural+firstLowerCase() {
		return new ArrayList<>($name+firstLowerCase~Map.values());
	}
end


def trigger(getterSignature)
	public $name+FirstUpperCase $name+firstLowerCase(String id);

	public List<$name+FirstUpperCase> $name+Plural+firstLowerCase();
end